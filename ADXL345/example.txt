/*	сохраняем данный файл в кодировке UTF-8		*/

	author: Golinskiy Konstantin	e-mail: golinskiy.konstantin@gmail.com
	
	/*	
		Для настроек заходим в фаил ADXL345_config.h там выбираем адрес устройства и указываем выбраную шину I2C	
	*/
	
/*

	Подключение:
	
				VDD 							Напряжение питания от 2,0 В до 3,6 В
				GND 
				CS								Выбор режима работы SPI/I2C если он подтянут к HIGH работает по I2C если к LOW то с SPI ( у модуля по умолчанию подтянут к HIGH )
				INT1							Выход прерывания 1. при включении прерывания незабываем подтянуть его к провотиположному питанию, по умолчанию стоит прерывание по восходящему фронту ( активный уровень HIGH )
				INT2							Выход прерывания 2. при включении прерывания незабываем подтянуть его к провотиположному питанию, по умолчанию стоит прерывание по восходящему фронту ( активный уровень HIGH )
				SDO/ALT						Последовательный вывод данных (SPI 4-Wire MISO) / Альтернативный I2C Выбор адреса (I2C). ( у модуля меняет адрес шины I2C подтянут к LOW ( default ) )
				SDA/SDI/SDIO			Серийные данные (I2C)/Последовательный ввод данных (SPI 4-Wire MOSI)/Последовательный ввод и вывод данных (SPI 3-Wire). 
				SCL/SCLK					Часы последовательной связи. SCL - это часы для I2C, а SCLK - это часы для SPI.
				
				
				для SPI -> maximum SPI clock speed is 5 MHz -> (CPOL) = 1 (HIGH) and clock phase (CPHA) = 1 (2EDGE)
*/


//===================================================================================================

#include "ADXL345.h"

// для расчетов углов наклона датчика
#include <math.h> 

float roll = 0.0f;
float pitch = 0.0f;
float rollF = 0.0f;
float pitchF = 0.0f;

// создаем глобальные переменные int16_t для записи RAW данных с осей X Y Z значения от - до +
int16_t X_axis_raw_value = 0;
int16_t Y_axis_raw_value = 0;
int16_t Z_axis_raw_value = 0;

// создаем глобальные переменные double для записи данных с осей X Y Z значения от - до + 
// для расчета Ускорение свободного падения X Y Z ( метр на секунду в квадрате (метр в секунду за секунду), м/с² )
double X_axis_value_gravity = 0.;
double Y_axis_value_gravity = 0.;
double Z_axis_value_gravity = 0.;



// создаем флаг для работы с прырыванием
volatile uint8_t interrupt_flag = 0;

// переменная в которую считаем индитификатор модуля ( Reset Value 0b11100101 - > 0xE5 Device ID )
uint8_t ID;

//===================================================================================================




	.........
	.........

main()=============================================================================================================================
	
	  //=======================================================================================================

	//-------------------------------------------------------------------------------------------------------------------------------------
	  // читаем ID устройства, по dataSheet должно быть 0xE5
	  ID = ADXL345_getDeviceID();
	
	
	
// только для SPI ------------------	
#if !(defined ADXL345_I2C_MODE) && (defined ADXL345_SPI_MODE)		
		// If Set (1) Puts Device in 3-wire Mode
		// If Set (0) Puts Device in 4-wire SPI Mode
		// Default = 1
		ADXL345_setBitSPI( 0 );
#endif		
//----------------------------------

		
		
	  //-------------------------------------------------------------------------------------------------------------------------------------
		// устанавливаем частоту измерения ( в активном режиме )(по умолчанию 100 Гц, ток потребления в этом режиме 140 мкА)
		ADXL345_setRate( ADXL345_25_Hz );
		// читаем текущую частоту измерения ( если нужно )
		// uint8_t data = ADXL345_getRate();

		
	  //-------------------------------------------------------------------------------------------------------------------------------------
		// включаем  или выключаем режим ниского энерго потребления ( при включенной частоты ограниченны )
		// true - on   false - off
		// частоты которые нужно установить если режим включен 400 200 100 50 25 12,5 ( другие частоты не подерживает )
		ADXL345_setLowPowerMode( true );
		// считываем (включен или выключен ) режим ниского энерго потребления ( при включенной частоты ограниченны )
		// uint8_t data = ADXL345_getLowPowerMode();
		
		
		//-------------------------------------------------------------------------------------------------------------------------------------
		// устанавливаем активный уровень срабатывания прерывания HIGH of LOW (по умолчанию HIGH )
		// true - HIGH   false - LOW
		// незабываем подключить подтяжку к противопаложному сигналу
		ADXL345_setInterruptsActiveLevel( true );
		// считываем активный уровень срабатывания прерывания HIGH of LOW (по умолчанию HIGH )
		// uint8_t data = ADXL345_getInterruptsActiveLevel();
		
		
		//-------------------------------------------------------------------------------------------------------------------------------------
		// установить диапазон измерения (максимальная чувствительность + -2g)
		// ( 0x00 = 2g,  0x01 = 4g,  0x02 = 8g,  0x03 = 16g ) (по умолчанию 2g )
		// 1g эквивалентна силе гравитации, действующей на неподвижный объект, покоящийся на поверхности Земли.
		ADXL345_setSensitivity( ADXL345_2G );
		// считываем диапазон измерения (максимальная чувствительность + -2g)
		// uint8_t data = ADXL345_getSensitivity();


		//==== CALIB ==============================================================
		// Калибровка осей акселерометра ( нужна для получения градусов наклона,
		// если это не нужно калибровать нет смысла, для более точного получения градусов наклона ADXL345_setSensitivity() устанавливать на ADXL345_16G )
		// запускаем калибровку после установки ADXL345_setSensitivity()
		// в момент калибровки нужно вращать ( крутить ) датчик во всех направлениях ( но окуратно без ударов и резких движений так как они некоректно влияют на калибровку )
		// в этот момент калибровка будет записывать в функцию максимум и минимум значения как только значения запишуться и новых небудет 
		// то по истечении времени #define TIME_CALIB_END калибровка закончиться и в датчик будут записаны смещения ADXL345_setAxisOffset_ для всех осей
		// эти данные храняться в датчике пока есть питание ( после перезагрузки там будут 0 )
		// если мы хотим при следующем включении не калибровать то можно после калибровки 
		// с помощью функций ADXL345_getAxisOffset_ считать все смещения и записать в EEPROM. 
		// а при запуске устройства оттуда считывать и уже напрямую записывать в датчик без калибровки с помощью функции ADXL345_setAxisOffset_
		//ADXL345_AccelerometerCalibration();
		//=========================================================================


			
		//-------------------------------------------------------------------------------------------------------------------------------------
		// делаем смещение по X Y оси от -150mg до +150mg ( 1 еденица равна 15.6mg )
		//ADXL345_setAxisOffsetX( 0 );
		//ADXL345_setAxisOffsetY( 0 );
		// делаем смещение по оси Z от -250mg до +250mg ( 1 еденица равна 15.6mg )
		//ADXL345_setAxisOffsetZ( 0 );
		
		// считываем смещение
		//int8_t x = ADXL345_getAxisOffsetX();
		//int8_t y = ADXL345_getAxisOffsetY();
		//int8_t z = ADXL345_getAxisOffsetZ();
		//-------------------------------------------------------------------------------------------------------------------------------------
		
		
		
		
		//######### пример активного режима и режима простоя ###################################################################################
		//--------------------------------------------------------------------------------------------------------------------------------------
		// включаем оси для режима активный и неактивный с которыми будем работать
		// включаем все оси для активного режима и режима простоя
		// по умолчанию все оси включены
		//ADXL345_setAxisActInactEnable( ADXL345_ACT_X | ADXL345_ACT_Y | ADXL345_ACT_Z | ADXL345_INACT_X | ADXL345_INACT_Y | ADXL345_INACT_Z );
		// считываем какие оси включены для режима активный и неактивный с которыми будем работать
		// по умолчанию все оси включены
		// венет маску битов ADXL345_ACT_X | ADXL345_ACT_Y | ADXL345_ACT_Z | ADXL345_INACT_X | ADXL345_INACT_Y | ADXL345_INACT_Z
		// где бит 1 та ось включена
		//uint8_t data = ADXL345_getAxisActInactEnable();
		
		
		
		//--------------------------------------------------------------------------------------------------------------------------------------
		// выключаем оси для режима активный и неактивный с которыми не будем работать
		// по умолчанию все оси включены
		//ADXL345_setAxisActInactDisable( ADXL345_INACT_X | ADXL345_INACT_Y | ADXL345_INACT_Z );
		// считываем какие оси выключены для режима активный и неактивный с которыми будем работать
		// венет маску битов ADXL345_ACT_X | ADXL345_ACT_Y | ADXL345_ACT_Z | ADXL345_INACT_X | ADXL345_INACT_Y | ADXL345_INACT_Z
		// где бит 1 та ось выключена
		// по умолчанию все оси включены
		//uint8_t data = ADXL345_getAxisActInactDisable();
		
		
		
		//--------------------------------------------------------------------------------------------------------------------------------------
		// режим "активный" ( срабатывает при движении ) выбираем чувствительность от 1 до 255 (включительно )
		//ADXL345_setActiveSensorSensitivity( 2 );
		// считываем чувствительность режим Активный ( срабатывает при движении ) вернет от 1 до 255 (включительно )
		//uint8_t data = ADXL345_getActiveSensorSensitivity();
	


		//--------------------------------------------------------------------------------------------------------------------------------------
		// режим "неактивный" ( срабатывает при остановке движения ) выбираем чувствительность от 1 до 255 (включительно )
		//ADXL345_setInactiveSensorSensitivity( 2 );
		// считываем чувствительность режим Неактивный ( срабатывает при остановке движения ) вернет от 1 до 255 (включительно )
		//uint8_t data = ADXL345_getInactiveSensorSensitivity();
		
		
		
		//--------------------------------------------------------------------------------------------------------------------------------------
		// режим "неактивный" ( срабатывает при остановке движения ) выбираем время через которое 
		// после начала неактивности сенсора сработает прерывание от 1 до 255 (включительно )
		// значение в миллисекундах
		//ADXL345_setInactiveSensorTime( 1 );
		// режим Неактивный ( срабатывает при остановке движения ) вернет время через которое 
		// после начала неактивности сенсора сработает прерывание от 1 до 255 (включительно )
		// значение в миллисекундах
		//uint8_t data = ADXL345_getInactiveSensorTime();
		
		
		
		//--------------------------------------------------------------------------------------------------------------------------------------
		// указываем прерывания которые будут на ножке INT1	( по умолчанию все будут на INT1 )
		// настраиваем до включения самого прерывания
		//ADXL345_setInterruptINT1( ADXL345_INT_ACTIVITY /* | ADXL345_INT_DOUBLE_TAP */ );
		// считываем прерывания которые будут на ножке INT1	( по умолчанию все будут на INT1 )
		// вернет байт ( маску ) где бит 1 то прерывание включено
		// ADXL345_INT_FREE_FALL  ADXL345_INT_DOUBLE_TAP  ADXL345_INT_SINGLE_TAP и т.д.
		//uint8_t data = ADXL345_getInterruptINT1();
		
		
		
		// указываем прерывания которые будут на ножке INT2
		// настраиваем до включения самого прерывания
		//ADXL345_setInterruptINT2( ADXL345_INT_INACTIVITY );
		// считываем прерывания которые будут на ножке INT2
		// вернет байт ( маску ) где бит 1 то прерывание включено
		// ADXL345_INT_FREE_FALL  ADXL345_INT_DOUBLE_TAP  ADXL345_INT_SINGLE_TAP и т.д.
		//uint8_t data = ADXL345_getInterruptINT2();
		
		
		
		//--------------------------------------------------------------------------------------------------------------------------------------
		// выключаем прерывание
		// ADXL345_INT_DOUBLE_TAP ADXL345_INT_SINGLE_TAP и т.д.
		//ADXL345_setInterruptDisable( ADXL345_INT_ALL );	// выключаем все прерывания
		// считываем какие прерывания выключены
		// вернет байт ( по маске ) нужно проверить где 1 то прерывание выключено
		// ADXL345_INT_DOUBLE_TAP ADXL345_INT_SINGLE_TAP и т.д.т.д.
		//uint8_t data = ADXL345_getInterruptDisable();
		
		//--------------------------------------------------------------------------------------------------------------------------------------
		// включаем прерывание
		// включать прерывание нужно только после всех настоек связаным с ним
		//ADXL345_setInterruptEnable( ADXL345_INT_ACTIVITY | ADXL345_INT_INACTIVITY );
		// считываем какие прерывания включены
		// включать прерывание нужно только после всех настоек связаным с ним
		// вернет байт ( по маске ) нужно проверить где 1 то прерывание включено
		// ADXL345_INT_DOUBLE_TAP ADXL345_INT_SINGLE_TAP и т.д.
		// uint8_t data = ADXL345_getInterruptEnable();
		
		
		//######################################################################################################################################
		
		
		//###################### пример двойного или одинарного удара ##########################################################################
		
		//--------------------------------------------------------------------------------------------------------------------------------------
		// включаем оси для режима двойной удар одинарный удар с которыми будем работать
		// по умолчанию все оси включены
		ADXL345_setAxisDubSingEnable( ADXL345_DUB_SIN_FF_X | ADXL345_DUB_SIN_FF_Y | ADXL345_DUB_SIN_FF_Z );
		// считываем какие оси выключены для режима двойной удар одинарный удар с которыми будем работать
		// венет маску битов ADXL345_DUB_SIN_FF_X | ADXL345_DUB_SIN_FF_Y | ADXL345_DUB_SIN_FF_Z
		// где бит 1 та ось включена
		// по умолчанию все оси включены
		//uint8_t data = ADXL345_getAxisDubSingEnable();
		
		
		
		
		//--------------------------------------------------------------------------------------------------------------------------------------
		// выключаем оси для режима двойной удар одинарный удар с которыми не будем работать
		// по умолчанию все оси включены
		//ADXL345_setAxisDubSingDisable( ADXL345_DUB_SIN_FF_X );
		// считываем какие оси выключены для режима двойной удар одинарный удар с которыми не будем работать
		// венет маску битов ADXL345_DUB_SIN_FF_X | ADXL345_DUB_SIN_FF_Y | ADXL345_DUB_SIN_FF_Z
		// где бит 1 та ось выключена
		// по умолчанию все оси включены
		//uint8_t data = ADXL345_getAxisDubSingDisable();
		
		
		
		
		//--------------------------------------------------------------------------------------------------------------------------------------
		// режим Двойной УДАР и Одинарный УДАР ( срабатывает при двойном или одинарном ударе ) выбираем чувствительность от 1 до 255 (включительно )
		ADXL345_setDoubleSingleSensorSensitivity( 20 );
		// режим Двойной УДАР и Одинарный УДАР ( срабатывает при двойном или одинарном ударе ) 
		// вернет чувствительность от 1 до 255 (включительно )
		// uint8_t data = ADXL345_getDoubleSingleSensorSensitivity();




		//--------------------------------------------------------------------------------------------------------------------------------------
		// режим Двойной УДАР и Одинарный УДАР ( срабатывает при двойном или одинарном ударе ) продолжительность удара от 1 до 255 (включительно )
		// каждая еденица равна 625 us
		ADXL345_setDoubleSingleSensorDur( 60 );
		// режим Двойной УДАР и Одинарный УДАР ( срабатывает при двойном или одинарном ударе ) 
		// вернет продолжительность удара от 1 до 255 (включительно )
		// каждая еденица равна 625 us
		// uint8_t data = ADXL345_getDoubleSingleSensorDur();
		
		
		
		//--------------------------------------------------------------------------------------------------------------------------------------
		// режим Двойной УДАР и Одинарный УДАР ( срабатывает при двойном или одинарном ударе ) временная задержка между мериями ударов от 1 до 255 (включительно )
		// Время задержки (Latency) устанавливает время после удара, в течении которого НЕ МОЖЕТ быть
		// зарегистрирован второй удар (предохранение от дребезга):
		// каждая еденица равна 1.25 ms
		ADXL345_setDoubleSingleSensorLatency( 80 );
		// режим Двойной УДАР и Одинарный УДАР ( срабатывает при двойном или одинарном ударе ) 
		// вернет временная задержка между мериями ударов от 1 до 255 (включительно )
		// Время задержки (Latency) устанавливает время после удара, в течении которого НЕ МОЖЕТ быть
		// зарегистрирован второй удар (предохранение от дребезга):
		// каждая еденица равна 1.25 ms
		//uint8_t data = ADXL345_getDoubleSingleSensorLatency();
		
		
		
		
		//--------------------------------------------------------------------------------------------------------------------------------------
		// режим Двойной УДАР и Одинарный УДАР ( срабатывает при двойном или одинарном ударе ) временное окно между ударами от 1 до 255 (включительно )
		// каждая еденица равна 1.25 ms
		ADXL345_setDoubleSingleSensorWindow( 200 );
		// режим Двойной УДАР и Одинарный УДАР ( срабатывает при двойном или одинарном ударе ) 
		// вернет временное окно между ударами от 1 до 255 (включительно )
		// каждая еденица равна 1.25 ms
		// uint8_t data = ADXL345_getDoubleSingleSensorWindow();
		
		
		
		//--------------------------------------------------------------------------------------------------------------------------------------
		// указываем прерывания которые будут на ножке INT1	( по умолчанию все будут на INT1 )
		// настраиваем до включения самого прерывания
		ADXL345_setInterruptINT1( ADXL345_INT_DOUBLE_TAP /*ADXL345_INT_SINGLE_TAP*/ );
		// считываем прерывания которые будут на ножке INT1	( по умолчанию все будут на INT1 )
		// вернет байт ( маску ) где бит 1 то прерывание включено
		// ADXL345_INT_FREE_FALL  ADXL345_INT_DOUBLE_TAP  ADXL345_INT_SINGLE_TAP и т.д.
		//uint8_t data = ADXL345_getInterruptINT1();
		
		
		
		//--------------------------------------------------------------------------------------------------------------------------------------	
		// выключаем прерывание
		// ADXL345_INT_DOUBLE_TAP ADXL345_INT_SINGLE_TAP и т.д.
		ADXL345_setInterruptDisable( ADXL345_INT_ALL );	// выключаем все прерывания
		// считываем какие прерывания выключены
		// вернет байт ( по маске ) нужно проверить где 1 то прерывание выключено
		// ADXL345_INT_DOUBLE_TAP ADXL345_INT_SINGLE_TAP и т.д.т.д.
		//uint8_t data = ADXL345_getInterruptDisable();
		
		
		//--------------------------------------------------------------------------------------------------------------------------------------
		// включаем прерывание
		// включать прерывание нужно только после всех настоек связаным с ним
		ADXL345_setInterruptEnable( ADXL345_INT_DOUBLE_TAP/* ADXL345_INT_SINGLE_TAP*/  );
		// считываем какие прерывания включены
		// включать прерывание нужно только после всех настоек связаным с ним
		// вернет байт ( по маске ) нужно проверить где 1 то прерывание включено
		// ADXL345_INT_DOUBLE_TAP ADXL345_INT_SINGLE_TAP и т.д.
		// uint8_t data = ADXL345_getInterruptEnable();
		
		
		//######################################################################################################################################


		//######## пример свободного падения ###################################################################################################
		
		//--------------------------------------------------------------------------------------------------------------------------------------
		// режим СВОБОДНОЕ падение ( срабатывает при свободном падении ) выбираем чувствительность от 1 до 255 (включительно )
		// рекомендуемое (0x05 to 0x09) одна еденица равна (вес 62.5 mg)
		//ADXL345_setFreeFallSensorSensitivity( 3 );
		// режим Свободное падение ( срабатывает при свободном падении ) считываем чувствительность от 1 до 255 (включительно )
		// рекомендуемое (0x05 to 0x09) одна еденица равна (вес 62.5 mg)
		// uint8_t data = ADXL345_getFreeFallSensorSensitivity();
	


		//--------------------------------------------------------------------------------------------------------------------------------------
		// режим СВОБОДНОЕ падение ( срабатывает при свободном падении ) время, которое должно пройти для засекания 
		// свободного падения . значение от 1 до 255 одна еденица 5 мс, рекомендуют (0x14 to 0x46)
		//ADXL345_setFreeFallSensorTime( 2 );
		// режим Свободное падение ( срабатывает при свободном падении ) считываем время, которое должно пройти для засекания 
		// свободного падения . значение от 1 до 255 одна еденица 5 мс, рекомендуют (0x14 to 0x46)
		// uint8_t data = ADXL345_getFreeFallSensorTime();
		
		
		//--------------------------------------------------------------------------------------------------------------------------------------
		// указываем прерывания которые будут на ножке INT1	( по умолчанию все будут на INT1 )
		// настраиваем до включения самого прерывания
		//ADXL345_setInterruptINT1( ADXL345_INT_FREE_FALL );
		// считываем прерывания которые будут на ножке INT1	( по умолчанию все будут на INT1 )
		// вернет байт ( маску ) где бит 1 то прерывание включено
		// ADXL345_INT_FREE_FALL  ADXL345_INT_DOUBLE_TAP  ADXL345_INT_SINGLE_TAP и т.д.
		//uint8_t data = ADXL345_getInterruptINT1();



		//--------------------------------------------------------------------------------------------------------------------------------------
		// выключаем прерывание
		// ADXL345_INT_DOUBLE_TAP ADXL345_INT_SINGLE_TAP и т.д.
		//ADXL345_setInterruptDisable( ADXL345_INT_ALL );	// выключаем все прерывания
		// считываем какие прерывания выключены
		// вернет байт ( по маске ) нужно проверить где 1 то прерывание выключено
		// ADXL345_INT_DOUBLE_TAP ADXL345_INT_SINGLE_TAP и т.д.т.д.
		//uint8_t data = ADXL345_getInterruptDisable();
		
		//--------------------------------------------------------------------------------------------------------------------------------------
		// включаем прерывание
		// включать прерывание нужно только после всех настоек связаным с ним
		//ADXL345_setInterruptEnable( ADXL345_INT_FREE_FALL );
		// считываем какие прерывания включены
		// включать прерывание нужно только после всех настоек связаным с ним
		// вернет байт ( по маске ) нужно проверить где 1 то прерывание включено
		// ADXL345_INT_DOUBLE_TAP ADXL345_INT_SINGLE_TAP и т.д.
		// uint8_t data = ADXL345_getInterruptEnable();
		
		//######################################################################################################################################
		
	  //-------------------------------------------------------------------------------------------------------------------------------------

		
		//---------------------------------------------------------------------------------------------------------------------------------------------------------
		// режим ожидания, при включенном замер не ведет при выключеном ведет замеры
		// true - включаем режим ожидания false - выключаем режим ожидания
		ADXL345_setStandbyMode( false );
		// считываем режим ожидания, при включенном замер не ведет при выключеном ведет замеры
		// true - включен режим ожидания false - выключен режим ожидания
		// uint8_t data = ADXL345_getStandbyMode();
	
		
		//-------------------------------------------------------------------------------------------------------------------------------------
		
		
		//== Перед запуском очищаем регистр прерывания ( путем чтения его ) иначе модуль прерывание не дернет и данные осей выдавать не будет =================
		//---------------------------------------------------------------------------------------------------------------------------------------------------------
		uint8_t type_interrupt = ADXL345_ReadInterruptReg();
		//---------------------------------------------------------------------------------------------------------------------------------------------------------
		//=====================================================================================================================================================
		
		// если в конфигураторе проекта не ключили прерывание пина МК то включаем
	  //HAL_NVIC_EnableIRQ(EXTI1_IRQn);
		
//===================================================================================================================================================================

  
	.........
	.........
	.........

while(1)===========================================================================================================================

	
		//============================================================================================================
		
#if 1	
		
		//#### пример простого получения данных с осей датчика ########################################################
			//-------------------------------------------------------------------------
		

			// получаем данные по осям ( также их можно получать по прерыванию )
			X_axis_raw_value = ADXL345_ReadRawAxisX();			
			Y_axis_raw_value = ADXL345_ReadRawAxisY();
			Z_axis_raw_value = ADXL345_ReadRawAxisZ();
			

		
	
			// расчет Ускорение свободного падения X Y Z ( метр на секунду в квадрате (метр в секунду за секунду), м/с² )
			X_axis_value_gravity = (double)X_axis_raw_value * ( 1.0 / SensitivityRangesResolution[ ADXL345_getSensitivity() ] ) * SENSORS_GRAVITY_EARTH;	// m/s^2
			Y_axis_value_gravity = (double)Y_axis_raw_value * ( 1.0 / SensitivityRangesResolution[ ADXL345_getSensitivity() ] ) * SENSORS_GRAVITY_EARTH;	// m/s^2
			Z_axis_value_gravity = (double)Z_axis_raw_value * ( 1.0 / SensitivityRangesResolution[ ADXL345_getSensitivity() ] ) * SENSORS_GRAVITY_EARTH;	// m/s^2

		
		
			// или можно одним махом считывать все три значения
			//ADXL345_ReadAxisXYZ( &X_axis_value, &Y_axis_value, &Z_axis_value );
			
			//--------------------------------------------------------------------------
			
			
			
			
			//===== получаем градусы наклона ( крен и тангаж ) ==========================================================
			
			// расчет данных с датчика с учетом коэффициента (взят с даташита ) который зависит от установленного 
			// диапазона измерений ( 0x00 = 2g,  0x01 = 4g,  0x02 = 8g,  0x03 = 16g ) (по умолчанию 2g ADXL345_2G )
			// данные расчеты нам нужны для получения градусов наклона
			double X_out = (double)X_axis_raw_value / SensitivityRangesResolution[ ADXL345_getSensitivity() ];
			double Y_out = (double)Y_axis_raw_value / SensitivityRangesResolution[ ADXL345_getSensitivity() ];
			double Z_out = (double)Z_axis_raw_value / SensitivityRangesResolution[ ADXL345_getSensitivity() ];
		
			// варианты расчета углов 
			// углы от (0 до 90 и от 90 до 0 ) и (0 до -90 и от -90 до 0 ) ( немного лучше измерения )
			#if 0
						// Calculate Roll and Pitch (rotation around X-axis, rotation around Y-axis)
						roll = atan(Y_out / sqrt(pow(X_out, 2) + pow(Z_out, 2))) * 180 / PI;
						pitch = atan(X_out / sqrt(pow(Y_out, 2) + pow(Z_out, 2))) * 180 / PI;
						
			#endif
				
			// углы от (0 до 360) ( но из-за оси Z в некоторых позах некоректно измеряет угол )
			#if 0
					roll = atan2(Y_out , Z_out) * 180 / PI;
					if( Y_out < 0 ){ roll = 360 + roll; }
					
					pitch = atan2((X_out) , Z_out) * 180 / PI;
					if( X_out < 0 ){ pitch = 360 + pitch; }
			#endif

			
			#if 1
					X_out /= 100.0f;
					Y_out /= 100.0f;
					Z_out /= 100.0f;	

					float fNormAcc = sqrt((X_out*X_out)+(Y_out*Y_out)+(Z_out*Z_out));

					float fSinRoll = -Y_out/fNormAcc;
					float fCosRoll = sqrt((fSinRoll * fSinRoll));				// sqrt((1.0 - fSinRoll * fSinRoll));
					if( Y_out < 0 ){ fCosRoll = (-1 * fCosRoll); }
					
					
					float fSinPitch = -X_out/fNormAcc;
					float fCosPitch = sqrt((fSinPitch * fSinPitch)); 		//sqrt((1.0 - fSinPitch * fSinPitch));
					if( X_out < 0 ){ fCosPitch = (-1 * fCosPitch); }
					
					
					// 180 <- 90 -> 0 .... 0 <- 90 -> 180
					roll = acosf(fCosRoll) * 180/PI;
					pitch = acosf(fCosPitch) * 180/PI;
					
					// 180 <- 90 -> 0 .... 0 <- -90 -> -180
					if( Z_out < 0 )roll *= -1;
					if( Z_out < 0 )pitch *= -1;

			#endif	


			
			// Low-pass filter фильтр простой ( плавныое изменение )
			rollF = 0.94 * rollF + 0.06 * roll;
			pitchF = 0.94 * pitchF + 0.06 * pitch;
			//============================================================================================================
			
#endif			
	
		//##############################################################################################################
		
	  // check is needed if other modules are added to the devices that also cause an interrupt
	  if( interrupt_flag )
	  {
				
			HAL_GPIO_WritePin(LED_GPIO_Port, LED_Pin, GPIO_PIN_SET);
			HAL_Delay(1000);
			HAL_GPIO_WritePin(LED_GPIO_Port, LED_Pin, GPIO_PIN_RESET);

			//---------------------------------------------------------------------------------------------------------------------------------------------------------
			// ( важно!!! внутри прерывания нельзя читать байт который указывает на тип прерывания датчика,
			// иначе новое прерывание уже не отработает, поєтому взводим флаг и в цикле уже читаем тип прерывания датчика)
			// читаем байт в котором побитово можно увидеть что именно ыфзвало прерывание, нужно читать после каждого прерывания ( биты комбенируем через маски )
			// ADXL345_INT_SINGLE_TAP  	0x40 - однократный удар
			// ADXL345_INT_DOUBLE_TAP 	0x20 - двойной удар
			// ADXL345_INT_ACTIVITY	 		0x10 - любая активность ( удары )
			// ADXL345_INT_INACTIVITY 	0x08 - бездействие
			// ADXL345_INT_FREE_FALL  	0x04 - свободное падение
			// ADXL345_INT_DATA_READY 	0x80 - данные готовы

			uint8_t type_interrupt = ADXL345_ReadInterruptReg();
			//---------------------------------------------------------------------------------------------------------------------------------------------------------

			interrupt_flag = 0;
		}
		
		//=====================================================================================================
		
			
	.........
	.........
	.........
	.........

=== end while(1) ==================================================================================================================
=== end main() ====================================================================================================================


//---------------------------------------------------------------------------------------------------------------------------------------------------
//=========================================================================================
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
{
	// проверяем какое именно прерывание отработало -  INTERRUPT_1_Pin
	// ( важно!!! внутри прерывания нельзя читать байт который указывает на тип прерывания датчика,
	// иначе новое прерывание уже не отработает, поєтому взводим флаг и в цикле уже читаем тип прерывания датчика)
	if(GPIO_Pin == INTERRUPT_1_Pin )
	{
		interrupt_flag = 1;
	}
}

//=========================================================================================

//---------------------------------------------------------------------------------------------------------------------------------------------------