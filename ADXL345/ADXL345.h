/*
	
  ******************************************************************************
  * @file 					( фаил ):   ADXL345.h
  * @brief 			( описание ):  	
  ******************************************************************************
  * @attention 	( внимание ):	author: Golinskiy Konstantin	e-mail: golinskiy.konstantin@gmail.com
  ******************************************************************************
  
*/

#ifndef _ADXL345_H
#define _ADXL345_H

#ifdef __cplusplus
extern "C" {
#endif

/* Includes ----------------------------------------------------------*/

#include "main.h"

#include "ADXL345_config.h"
#include "stdbool.h"


#define SENSORS_GRAVITY_EARTH 		(9.80665F) // < Earth's gravity in m/s^2

#define abs(x) ((x)>0?(x):-(x))

#define PI 3.1415926535897932384626433832795


// REGISTER MAP Table 19.
// регистры датчика
#define	DEVID											0x00		// Device ID =========( Reset Value 0b11100101 - > 0xE5 Device ID )
#define	THRESH_TAP								0x1D		// Tap threshold
#define	OFSX											0x1E		// X-axis offset
#define	OFSY											0x1F		// Y-axis offset
#define	OFSZ											0x20		// Z-axis offset
#define	DUR												0x21  	// Tap duration
#define	LATENT										0x22  	// Tap latency
#define	WINDOW										0x23  	// Tap window
#define	THRESH_ACT								0x24  	// Activity threshold
#define	THRESH_INACT							0x25  	// Inactivity threshold
#define	TIME_INACT								0x26  	// Inactivity time
#define	ACT_INACT_CTL							0x27  	// Axis enable control for activity and inactivity detection
#define	THRESH_FF									0x28  	// Free-fall threshold
#define	TIME_FF										0x29  	// Free-fall time
#define	TAP_AXES									0x2A  	// Axis control for single tap/double tap
#define	ACT_TAP_STATUS						0x2B  	// Source of single tap/double tap
#define	BW_RATE										0x2C  	// Data rate and power mode control =======( Reset Value 0b00001010 - > 0x0A )
#define	POWER_CTL									0x2D  	// Power-saving features control
#define	INT_ENABLE								0x2E  	// Interrupt enable control
#define	INT_MAP										0x2F  	// Interrupt mapping control
#define	INT_SOURCE								0x30  	// Source of interrupts =======( Reset Value 0b00000010 - > 0x02 )
#define	DATA_FORMAT								0x31  	// Data format control
#define	DATAX0										0x32  	// X-Axis Data 0
#define	DATAX1										0x33  	// X-Axis Data 1
#define	DATAY0										0x34  	// Y-Axis Data 0
#define	DATAY1										0x35  	// Y-Axis Data 1
#define	DATAZ0										0x36  	// Z-Axis Data 0
#define	DATAZ1										0x37  	// Z-Axis Data 1
#define	FIFO_CTL									0x38  	// FIFO control
#define	FIFO_STATUS								0x39  	// FIFO status


// Table 7. Typical Current Consumption vs. Data Rate 
// частота работы датчика
#define	ADXL345_0_10_Hz						0x00		// 0.10Гц 23мкА
#define	ADXL345_0_20_Hz						0x01		// 0.20Гц 23мкА
#define	ADXL345_0_39_Hz						0x02		// 0.39Гц 23мкА
#define	ADXL345_0_78_Hz						0x03		// 0.78Гц 23мкА
#define	ADXL345_1_56_Hz						0x04		// 1.56Гц 34мкА
#define	ADXL345_3_13_Hz						0x05		// 3.13Гц 40мкА
#define	ADXL345_6_25_Hz						0x06		// 6.25Гц 45мкА
#define	ADXL345_12_5_Hz						0x07		// 12.5Гц 50мкА
#define	ADXL345_25_Hz							0x08		// 25Гц 60мкА
#define	ADXL345_50_Hz							0x09		// 50Гц 90мкА
#define	ADXL345_100_Hz						0x0A		// 100Гц 140мкА	( по умолчанию )
#define	ADXL345_200_Hz						0x0B		// 200Гц 140мкА
#define	ADXL345_400_Hz						0x0C		// 400Гц 140мкА
#define	ADXL345_800_Hz						0x0D		// 800Гц 140мкА
#define	ADXL345_1600_Hz						0x0E		// 1600Гц 90мкА
#define	ADXL345_3200_Hz						0x0F		// 3200Гц 140мкА


// Table 21. g Range Setting 
// диапазон измерения	
//( 0x00 = 2g,  0x01 = 4g,  0x02 = 8g,  0x03 = 16g )
#define	ADXL345_2G								0x00			// 2g
#define	ADXL345_4G								0x01			// 4g
#define	ADXL345_8G								0x02			// 8g
#define	ADXL345_16G								0x03			// 16g

// включение и отключение осей для режима активного и простоя
#define ADXL345_ACT_X							0x40			// ось X ( активный режим - удары )
#define ADXL345_ACT_Y							0x20			// ось Y ( активный режим - удары )
#define ADXL345_ACT_Z							0x10			// ось Z ( активный режим - удары )
#define ADXL345_INACT_X						0x04			// ось X ( неактивный режим - бездействие )
#define ADXL345_INACT_Y						0x02			// ось Y ( неактивный режим - бездействие  )
#define ADXL345_INACT_Z						0x01			// ось Z ( неактивный режим - бездействие  )
#define ADXL345_DUB_SIN_FF_X			0x04			// ось X ( двойной и одинарный удар )
#define ADXL345_DUB_SIN_FF_Y			0x02			// ось Y ( двойной и одинарный удар )
#define ADXL345_DUB_SIN_FF_Z			0x01			// ось Z ( двойной и одинарный удар )

// номер прерывания ( на какую ножку его делать )
#define ADXL345_INT1							0x00
#define ADXL345_INT2							0x01

// тыпы прерываний ( включаеть или выключать )
#define ADXL345_INT_ALL						0xFF			// все прерывания
#define ADXL345_INT_DATA_READY 		0x80			// данные готовы
#define ADXL345_INT_SINGLE_TAP  	0x40			// однократный удар
#define ADXL345_INT_DOUBLE_TAP 		0x20 			// двойной удар
#define ADXL345_INT_ACTIVITY	 		0x10			// активный режим все удары
#define ADXL345_INT_INACTIVITY 		0x08			// неактивный режим ( режим простоя )
#define ADXL345_INT_FREE_FALL  		0x04			// режим свободного падения



#if (defined ADXL345_I2C_MODE) && !(defined ADXL345_SPI_MODE)
		extern I2C_HandleTypeDef ADXL345_I2C;
#elif !(defined ADXL345_I2C_MODE) && (defined ADXL345_SPI_MODE)
		extern SPI_HandleTypeDef ADXL345_SPI;
#endif


extern const uint16_t SensitivityRangesResolution[];
	



/* Functions prototypes ----------------------------------------------*/

//==================================================================================================================
//  функция возвращает ID устройства, Device ID =========( Reset Value 0b11100101 - > 0xE5 Device ID )
// читаем ID устройства, по dataSheet должно быть 0xE5
uint8_t ADXL345_getDeviceID( void );

//==================================================================================================================
// указываем частоту измерения ( в активном режиме )(по умолчанию 100 Гц, ток потребления в этом режиме 140 мкА)
// чем больше частота тем больше энергопотребление ( ADXL345_25_Hz )
void ADXL345_setRate(uint8_t value);

//==================================================================================================================
// считываем тукцщую частоту измерения ( в активном режиме )(по умолчанию 100 Гц, ток потребления в этом режиме 140 мкА)
// чем больше частота тем больше энергопотребление ( ADXL345_25_Hz )
uint8_t ADXL345_getRate(void);
	
//==================================================================================================================
// включаем  или выключаем режим ниского энерго потребления ( при включенной частоты ограниченны )
// true - on   false - off
// частоты которые нужно установить 400 200 100 50 25 12,5
void ADXL345_setLowPowerMode( bool value );

//==================================================================================================================
// считываем (включен или выключен ) режим ниского энерго потребления ( при включенной частоты ограниченны )
// true - on   false - off
bool ADXL345_getLowPowerMode(void);
	
//==================================================================================================================
// устанавливаем активный уровень срабатывания прерывания HIGH of LOW (по умолчанию HIGH )
// true - HIGH   false - LOW
// незабываем подключить подтяжку к противопаложному сигналу
void ADXL345_setInterruptsActiveLevel( bool level );

//==================================================================================================================
// считываем активный уровень срабатывания прерывания HIGH of LOW (по умолчанию HIGH )
// true - HIGH   false - LOW
// незабываем подключить подтяжку к противопаложному сигналу
bool ADXL345_getInterruptsActiveLevel(void);
	
//==================================================================================================================
// установить диапазон измерения (максимальная чувствительность + -2g)
// ( 0x00 = 2g,  0x01 = 4g,  0x02 = 8g,  0x03 = 16g ) (по умолчанию 2g ADXL345_2G )
// 1g эквивалентна силе гравитации, действующей на неподвижный объект, покоящийся на поверхности Земли.
void ADXL345_setSensitivity( uint8_t value );

//==================================================================================================================
// считываем диапазон измерения (максимальная чувствительность + -2g)
// ( 0x00 = 2g,  0x01 = 4g,  0x02 = 8g,  0x03 = 16g ) (по умолчанию 2g ADXL345_2G )
// 1g эквивалентна силе гравитации, действующей на неподвижный объект, покоящийся на поверхности Земли.
uint8_t ADXL345_getSensitivity(void);
	
//==================================================================================================================
// включаем оси для режима активный и неактивный с которыми будем работать
// ADXL345_ACT_X | ADXL345_ACT_Y | ADXL345_ACT_Z | ADXL345_INACT_X | ADXL345_INACT_Y | ADXL345_INACT_Z
// по умолчанию все оси включены
void ADXL345_setAxisActInactEnable( uint8_t axis );

//==================================================================================================================
// считываем какие оси включены для режима активный и неактивный с которыми будем работать
// венет маску битов ADXL345_ACT_X | ADXL345_ACT_Y | ADXL345_ACT_Z | ADXL345_INACT_X | ADXL345_INACT_Y | ADXL345_INACT_Z
// где бит 1 та ось включена
// по умолчанию все оси включены
uint8_t ADXL345_getAxisActInactEnable(void);

//==================================================================================================================
// выключаем оси для режима активный и неактивный с которыми не будем работать
// ADXL345_ACT_X | ADXL345_ACT_Y | ADXL345_ACT_Z | ADXL345_INACT_X | ADXL345_INACT_Y | ADXL345_INACT_Z
void ADXL345_setAxisActInactDisable( uint8_t axis );

//==================================================================================================================
// считываем какие оси выключены для режима активный и неактивный с которыми будем работать
// венет маску битов ADXL345_ACT_X | ADXL345_ACT_Y | ADXL345_ACT_Z | ADXL345_INACT_X | ADXL345_INACT_Y | ADXL345_INACT_Z
// где бит 1 та ось выключена
// по умолчанию все оси включены
uint8_t ADXL345_getAxisActInactDisable(void);

//==================================================================================================================
// включаем оси для режима двойной удар одинарный удар с которыми будем работать
// ADXL345_DUB_SIN_FF_X | ADXL345_DUB_SIN_FF_Y | ADXL345_DUB_SIN_FF_Z
// по умолчанию все оси включены
void ADXL345_setAxisDubSingEnable( uint8_t axis );

//==================================================================================================================
// считываем какие оси выключены для режима двойной удар одинарный удар с которыми будем работать
// венет маску битов ADXL345_DUB_SIN_FF_X | ADXL345_DUB_SIN_FF_Y | ADXL345_DUB_SIN_FF_Z
// где бит 1 та ось включена
// по умолчанию все оси включены
uint8_t ADXL345_getAxisDubSingEnable(void);
	
//==================================================================================================================
// выключаем оси для режима двойной удар одинарный удар с которыми не будем работать
// ADXL345_DUB_SIN_FF_X | ADXL345_DUB_SIN_FF_Y | ADXL345_DUB_SIN_FF_Z
// по умолчанию все оси включены
void ADXL345_setAxisDubSingDisable( uint8_t axis );

//==================================================================================================================
// считываем какие оси выключены для режима двойной удар одинарный удар с которыми не будем работать
// венет маску битов ADXL345_DUB_SIN_FF_X | ADXL345_DUB_SIN_FF_Y | ADXL345_DUB_SIN_FF_Z
// где бит 1 та ось выключена
// по умолчанию все оси включены
uint8_t ADXL345_getAxisDubSingDisable(void);

//==================================================================================================================
// режим АКТИВНЫЙ ( срабатывает при движении ) выбираем чувствительность от 1 до 255 (включительно )
void ADXL345_setActiveSensorSensitivity( uint8_t data );

//==================================================================================================================
// считываем чувствительность режим Активный ( срабатывает при движении ) вернет от 1 до 255 (включительно )
uint8_t ADXL345_getActiveSensorSensitivity(void);

//==================================================================================================================
// режим НЕАКТИВНЫЙ ( срабатывает при остановке движения ) выбираем чувствительность от 1 до 255 (включительно )
void  ADXL345_setInactiveSensorSensitivity( uint8_t data );

//==================================================================================================================
// считываем чувствительность режим Неактивный ( срабатывает при остановке движения ) вернет от 1 до 255 (включительно )
uint8_t ADXL345_getInactiveSensorSensitivity(void);

//==================================================================================================================
// режим НЕАКТИВНЫЙ ( срабатывает при остановке движения ) выбираем время через которое 
// после начала неактивности сенсора сработает прерывание от 1 до 255 (включительно )
// значение в миллисекундах
void ADXL345_setInactiveSensorTime( uint8_t data );

//==================================================================================================================
// режим Неактивный ( срабатывает при остановке движения ) вернет время через которое 
// после начала неактивности сенсора сработает прерывание от 1 до 255 (включительно )
// значение в миллисекундах
uint8_t ADXL345_getInactiveSensorTime(void);

//==================================================================================================================
// режим ДВОЙНОЙ УДАР и ОДИНАРНЫЙ УДАР ( срабатывает при двойном или одинарном ударе ) 
// выбираем чувствительность от 1 до 255 (включительно )
void ADXL345_setDoubleSingleSensorSensitivity( uint8_t data );

//==================================================================================================================
// режим Двойной УДАР и Одинарный УДАР ( срабатывает при двойном или одинарном ударе ) 
// вернет чувствительность от 1 до 255 (включительно )
uint8_t ADXL345_getDoubleSingleSensorSensitivity(void);
	
//==================================================================================================================
// режим ДВОЙНОЙ УДАР и ОДИНАРНЫЙ УДАР ( срабатывает при двойном или одинарном ударе ) 
// продолжительность удара от 1 до 255 (включительно )
// каждая еденица равна 625 us
void ADXL345_setDoubleSingleSensorDur( uint8_t data );

//==================================================================================================================
// режим Двойной УДАР и Одинарный УДАР ( срабатывает при двойном или одинарном ударе ) 
// вернет продолжительность удара от 1 до 255 (включительно )
// каждая еденица равна 625 us
uint8_t ADXL345_getDoubleSingleSensorDur(void);

//==================================================================================================================
// режим ДВОЙНОЙ УДАР и ОДИНАРНЫЙ УДАР ( срабатывает при двойном или одинарном ударе ) 
// временное окно между ударами от 1 до 255 (включительно )
// каждая еденица равна 1.25 ms
void ADXL345_setDoubleSingleSensorWindow( uint8_t data );

//==================================================================================================================
// режим Двойной УДАР и Одинарный УДАР ( срабатывает при двойном или одинарном ударе ) 
// вернет временное окно между ударами от 1 до 255 (включительно )
// каждая еденица равна 1.25 ms
uint8_t ADXL345_getDoubleSingleSensorWindow(void);

//==================================================================================================================
// режим ДВОЙНОЙ УДАР и ОДИНАРНЫЙ УДАР ( срабатывает при двойном или одинарном ударе ) 
// временная задержка между мериями ударов от 1 до 255 (включительно )
// Время задержки (Latency) устанавливает время после удара, в течении которого НЕ МОЖЕТ быть
// зарегистрирован второй удар (предохранение от дребезга):
// каждая еденица равна 1.25 ms
void ADXL345_setDoubleSingleSensorLatency( uint8_t data );

//==================================================================================================================
// режим Двойной УДАР и Одинарный УДАР ( срабатывает при двойном или одинарном ударе ) 
// вернет временная задержка между мериями ударов от 1 до 255 (включительно )
// Время задержки (Latency) устанавливает время после удара, в течении которого НЕ МОЖЕТ быть
// зарегистрирован второй удар (предохранение от дребезга):
// каждая еденица равна 1.25 ms
uint8_t ADXL345_getDoubleSingleSensorLatency(void);
	
//==================================================================================================================
// включаем прерывание
// включать прерывание нужно только после всех настоек связаным с ним
// ADXL345_INT_DOUBLE_TAP ADXL345_INT_SINGLE_TAP и т.д.
void ADXL345_setInterruptEnable( uint8_t value );

//==================================================================================================================
// считываем какие прерывания включены
// включать прерывание нужно только после всех настоек связаным с ним
// вернет байт ( по маске ) нужно проверить где 1 то прерывание включено
// ADXL345_INT_DOUBLE_TAP ADXL345_INT_SINGLE_TAP и т.д.
uint8_t ADXL345_getInterruptEnable(void);
	

//==================================================================================================================
// выключаем прерывание
// ADXL345_INT_DOUBLE_TAP ADXL345_INT_SINGLE_TAP и т.д.
void ADXL345_setInterruptDisable( uint8_t value );

//==================================================================================================================
// считываем какие прерывания выключены
// вернет байт ( по маске ) нужно проверить где 1 то прерывание выключено
// ADXL345_INT_DOUBLE_TAP ADXL345_INT_SINGLE_TAP и т.д.т.д.
uint8_t ADXL345_getInterruptDisable(void);
	
//==================================================================================================================
// указываем прерывания которые будут на ножке INT1	( по умолчанию все будут на INT1 )
// настраиваем до включения самого прерывания
void ADXL345_setInterruptINT1( uint8_t value );

//==================================================================================================================
// считываем прерывания которые будут на ножке INT1	( по умолчанию все будут на INT1 )
// вернет байт ( маску ) где бит 1 то прерывание включено
// ADXL345_INT_FREE_FALL  ADXL345_INT_DOUBLE_TAP  ADXL345_INT_SINGLE_TAP и т.д.
uint8_t ADXL345_getInterruptINT1(void);

//==================================================================================================================
// указываем прерывания которые будут на ножке INT2
// настраиваем до включения самого прерывания
void ADXL345_setInterruptINT2( uint8_t value );

//==================================================================================================================
// считываем прерывания которые будут на ножке INT2
// вернет байт ( маску ) где бит 1 то прерывание включено
// ADXL345_INT_FREE_FALL  ADXL345_INT_DOUBLE_TAP  ADXL345_INT_SINGLE_TAP и т.д.
uint8_t ADXL345_getInterruptINT2(void);

//==================================================================================================================
// режим ожидания, при включенном замер не ведет при выключеном ведет замеры
// true - включаем режим ожидания false - выключаем режим ожидания
void ADXL345_setStandbyMode( bool value );

//==================================================================================================================
// считываем режим ожидания, при включенном замер не ведет при выключеном ведет замеры
// true - включен режим ожидания false - выключен режим ожидания
bool ADXL345_getStandbyMode(void);

//==================================================================================================================
// режим СВОБОДНОЕ ПАДЕНИЕ ( срабатывает при свободном падении ) выбираем чувствительность от 1 до 255 (включительно )
// рекомендуемое (0x05 to 0x09) одна еденица равна (вес 62.5 mg)
void ADXL345_setFreeFallSensorSensitivity( uint8_t data );

//==================================================================================================================
// режим Свободное падение ( срабатывает при свободном падении ) считываем чувствительность от 1 до 255 (включительно )
// рекомендуемое (0x05 to 0x09) одна еденица равна (вес 62.5 mg)
uint8_t ADXL345_getFreeFallSensorSensitivity(void);

//==================================================================================================================
// режим СВОБОДНОЕ ПАДЕНИЕ ( срабатывает при свободном падении ) время, которое должно пройти для засекания 
// свободного падения . значение от 1 до 255 одна еденица 5 мс, рекомендуют (0x14 to 0x46)
void ADXL345_setFreeFallSensorTime( uint8_t data );

//==================================================================================================================
// режим Свободное падение ( срабатывает при свободном падении ) считываем время, которое должно пройти для засекания 
// свободного падения . значение от 1 до 255 одна еденица 5 мс, рекомендуют (0x14 to 0x46)
uint8_t ADXL345_getFreeFallSensorTime(void);

//==================================================================================================================
// после возникновения прерывания читаем его регист
// функция возвращает тип прерывание вызваное датчиком
// ( важно!!! внутри прерывания нельзя читать байт который указывает на тип прерывания датчика,
// иначе новое прерывание уже не отработает, поєтому взводим флаг и в цикле уже читаем тип прерывания датчика)
// читаем байт в котором побитово можно увидеть что именно ыфзвало прерывание, нужно читать после каждого прерывания ( биты комбенируем через маски )
// ADXL345_INT_SINGLE_TAP  	0x40 - однократный удар
// ADXL345_INT_DOUBLE_TAP 	0x20 - двойной удар
// ADXL345_INT_ACTIVITY	 		0x10 - любая активность ( удары )
// ADXL345_INT_INACTIVITY 	0x08 - бездействие
// ADXL345_INT_FREE_FALL  	0x04 - свободное падение
// ADXL345_INT_DATA_READY 	0x80 - данные готовы
uint8_t ADXL345_ReadInterruptReg(void);

//==================================================================================================================
// читаем  RAW  данные по оси X
int16_t ADXL345_ReadRawAxisX(void);	

//==================================================================================================================
// читаем  RAW  данные по оси Y
int16_t ADXL345_ReadRawAxisY(void);

//==================================================================================================================
// читаем  RAW данные по оси Z
int16_t ADXL345_ReadRawAxisZ(void);

//==================================================================================================================
// читаем данные по всем трем осям одновременно X Y Z
void ADXL345_ReadAxisXYZ(int16_t* x, int16_t* y, int16_t* z);

//==================================================================================================================
// в режиме SPI выбор 3 или 4 проводная линия
// If Set (1) Puts Device in 3-wire Mode
// If Set (0) Puts Device in 4-wire SPI Mode
// Default = 1
void ADXL345_setBitSPI( bool level );

//==================================================================================================================
// смещение OFSX: User Offset Adjustments in Twos Complement Format
// Scale Factor of 15.6mg/LSB
// делаем смещение по оси от -150mg до +150mg ( 1 еденица равна 15.6mg )
void ADXL345_setAxisOffsetX(int8_t data);

//==================================================================================================================
// считываем смещение OFSX: User Offset Adjustments in Twos Complement Format
// Scale Factor of 15.6mg/LSB
// делаем смещение по оси от -150mg до +150mg ( 1 еденица равна 15.6mg )
int8_t ADXL345_getAxisOffsetX(void);

//==================================================================================================================
// смещение OFSY: User Offset Adjustments in Twos Complement Format
// Scale Factor of 15.6mg/LSB
// делаем смещение по оси от -150mg до +150mg ( 1 еденица равна 15.6mg )
void ADXL345_setAxisOffsetY(int8_t data);

//==================================================================================================================
// считываем смещение OFSY: User Offset Adjustments in Twos Complement Format
// Scale Factor of 15.6mg/LSB
// делаем смещение по оси от -150mg до +150mg ( 1 еденица равна 15.6mg )
int8_t ADXL345_getAxisOffsetY(void);

//==================================================================================================================
// смещение OFSZ: User Offset Adjustments in Twos Complement Format
// Scale Factor of 15.6mg/LSB
// делаем смещение по оси Z от -250mg до +250mg ( 1 еденица равна 15.6mg )
void ADXL345_setAxisOffsetZ(int8_t data);

//==================================================================================================================
// считываем смещение OFSZ: User Offset Adjustments in Twos Complement Format
// Scale Factor of 15.6mg/LSB
// делаем смещение по оси Z от -250mg до +250mg ( 1 еденица равна 15.6mg ))
int8_t ADXL345_getAxisOffsetZ(void);

//==================================================================================================================
// Калибровка осей акселерометра ( нужна для получения градусов наклона,
// если это не нужно калибровать нет смысла, для более точного получения градусов наклона ADXL345_setSensitivity() устанавливать на ADXL345_16G )
// запускаем калибровку после установки ADXL345_setSensitivity()
// в момент калибровки нужно вращать ( крутить ) датчик во всех направлениях ( но окуратно без ударов и резких движений так как они некоректно влияют на калибровку )
// в этот момент калибровка будет записывать в функцию максимум и минимум значения как только значения запишуться и новых небудет 
// то по истечении времени #define TIME_CALIB_END калибровка закончиться и в датчик будут записаны смещения ADXL345_setAxisOffset_ для всех осей
// эти данные храняться в датчике пока есть питание ( после перезагрузки там будут 0 )
// если мы хотим при следующем включении не калибровать то можно после калибровки 
// с помощью функций ADXL345_getAxisOffset_ считать все смещения и записать в EEPROM. 
// а при запуске устройства оттуда считывать и уже напрямую записывать в датчик без калибровки с помощью функции ADXL345_setAxisOffset_
void ADXL345_AccelerometerCalibration(void);


#ifdef __cplusplus
}
#endif

#endif	/*	_ADXL345_H */

/************************ (C) COPYRIGHT GKP *****END OF FILE****/
