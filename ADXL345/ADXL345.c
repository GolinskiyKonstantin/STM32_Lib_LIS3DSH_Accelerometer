/*

  ******************************************************************************
  * @file 					( фаил ):   ADXL345.c
  * @brief 			( описание ):  	
  ******************************************************************************
  * @attention 	( внимание ):	author: Golinskiy Konstantin	e-mail: golinskiy.konstantin@gmail.com
  ******************************************************************************
  
*/

/* Includes ----------------------------------------------------------*/
#include "ADXL345.h"

//----------------------------------------------------------------------------------
// значение на которое нужно делить сырые данные с осей ADXL345_ReadRawAxis_ 
// в зависимости от того какой стоит ADXL345_getSensitivity ( 0x00 = 2g,  0x01 = 4g,  0x02 = 8g,  0x03 = 16g )
// данные из даташита
const uint16_t SensitivityRangesResolution[] = { 256, 128, 64, 32 };
//----------------------------------------------------------------------------------


//----------------------------------------------------------------------------------
static void ADXL345_MemRead( uint8_t reg, uint8_t *data, uint8_t size_data )
{
	#if (defined ADXL345_I2C_MODE) && !(defined ADXL345_SPI_MODE)
	
			HAL_I2C_Mem_Read(&ADXL345_I2C, ADXL345_ADDRESS, reg, I2C_MEMADD_SIZE_8BIT, data, size_data, 500);
	
	#elif !(defined ADXL345_I2C_MODE) && (defined ADXL345_SPI_MODE)
	
			reg |= 0x80;  // read operation
			reg |= 0x40;  // multibyte read
			
			HAL_GPIO_WritePin( CS_GPIO_Port, CS_Pin, GPIO_PIN_RESET );
	
			HAL_SPI_Transmit(&ADXL345_SPI, &reg, 1, 500 );
			HAL_SPI_Receive(&ADXL345_SPI, data, size_data, 500 );
	
			HAL_GPIO_WritePin( CS_GPIO_Port, CS_Pin, GPIO_PIN_SET );
	
	#endif
}
//----------------------------------------------------------------------------------

//----------------------------------------------------------------------------------
static void ADXL345_MasterTransmit( uint8_t *data, uint8_t size_data )
{
	#if (defined ADXL345_I2C_MODE) && !(defined ADXL345_SPI_MODE)
	
			HAL_I2C_Master_Transmit(&ADXL345_I2C, ADXL345_ADDRESS, data, size_data, 500);
	
	#elif !(defined ADXL345_I2C_MODE) && (defined ADXL345_SPI_MODE)
	
			data[0] = data[0] | 0x40;  // multibyte write
	
			HAL_GPIO_WritePin( CS_GPIO_Port, CS_Pin, GPIO_PIN_RESET );
	
			HAL_SPI_Transmit(&ADXL345_SPI, data, size_data, 500 );
	
			HAL_GPIO_WritePin( CS_GPIO_Port, CS_Pin, GPIO_PIN_SET );
	
	#endif
}
//----------------------------------------------------------------------------------


//----------------------------------------------------------------------------------




//===================================================================================================================
//  функция возвращает ID устройства, Device ID =========( Reset Value 0b11100101 - > 0xE5 Device ID )
// читаем ID устройства, по dataSheet должно быть 0xE5
uint8_t ADXL345_getDeviceID( void )
{
	uint8_t ID_device = 0;
	ADXL345_MemRead( DEVID, &ID_device, 1);
	return ID_device;
}
//==================================================================================================================


//==================================================================================================================
// указываем частоту измерения ( в активном режиме )(по умолчанию 100 Гц, ток потребления в этом режиме 140 мкА)
// чем больше частота тем больше энергопотребление ( ADXL345_25_Hz )
void ADXL345_setRate(uint8_t value)
{
	value &= 0x0F;
  uint8_t data_transmit[2];
	//читаем текущее значение регистра
	ADXL345_MemRead(BW_RATE, &data_transmit[1], 1);
  data_transmit[0] = BW_RATE;
	// применяем маску чтобы не перезаписать 4 бит
  data_transmit[1] = (data_transmit[1] & 0x10) | (value & 0x0F); 
  ADXL345_MasterTransmit(data_transmit, 2);
}
//==================================================================================================================


//==================================================================================================================
// считываем тукцщую частоту измерения ( в активном режиме )(по умолчанию 100 Гц, ток потребления в этом режиме 140 мкА)
// чем больше частота тем больше энергопотребление ( ADXL345_25_Hz )
uint8_t ADXL345_getRate(void)
{
  uint8_t data;
	//читаем текущее значение регистра
	ADXL345_MemRead(BW_RATE, &data, 1);
	return (data & 0x0F);
}
//==================================================================================================================


//==================================================================================================================
// включаем  или выключаем режим ниского энерго потребления ( при включенной частоты ограниченны )
// true - on   false - off
// частоты которые нужно установить 400 200 100 50 25 12,5
void ADXL345_setLowPowerMode( bool value )
{
	uint8_t data_transmit[2];
	//читаем текущее значение регистра
	ADXL345_MemRead(BW_RATE, &data_transmit[1], 1);
  data_transmit[0] = BW_RATE;
	
	// применяем маску чтобы не перезаписать
  if( value ){ data_transmit[1] = (data_transmit[1] & 0x0F) | 0x10; }
	else{ data_transmit[1] = (data_transmit[1] & 0x0F); }
	
  ADXL345_MasterTransmit(data_transmit, 2);
}
//==================================================================================================================


//==================================================================================================================
// считываем (включен или выключен ) режим ниского энерго потребления ( при включенной частоты ограниченны )
// true - on   false - off
bool ADXL345_getLowPowerMode(void)
{
  uint8_t data;
	//читаем текущее значение регистра
	ADXL345_MemRead(BW_RATE, &data, 1);
	return (data & 0x10);
}
//==================================================================================================================


//==================================================================================================================
// устанавливаем активный уровень срабатывания прерывания HIGH of LOW (по умолчанию HIGH )
// true - HIGH   false - LOW
// незабываем подключить подтяжку к противопаложному сигналу
void ADXL345_setInterruptsActiveLevel( bool level )
{
	uint8_t data_transmit[2];
	//читаем текущее значение регистра
	ADXL345_MemRead(DATA_FORMAT, &data_transmit[1], 1);
  data_transmit[0] = DATA_FORMAT;
	
	// применяем маску чтобы не перезаписать
  if( level ){ data_transmit[1] = (data_transmit[1] & 0xDF); }	// HIGH -> 0
	else{ data_transmit[1] = (data_transmit[1] & 0xDF) | 0x20; }	// LOW  -> 1
	
  ADXL345_MasterTransmit(data_transmit, 2);
}
//==================================================================================================================


//==================================================================================================================
// считываем активный уровень срабатывания прерывания HIGH of LOW (по умолчанию HIGH )
// true - HIGH   false - LOW
// незабываем подключить подтяжку к противопаложному сигналу
bool ADXL345_getInterruptsActiveLevel(void)
{
	uint8_t data;
	//читаем текущее значение регистра
	ADXL345_MemRead(DATA_FORMAT, &data, 1);
	return !(data & 0x20);
}
//==================================================================================================================


//==================================================================================================================
// установить диапазон измерения (максимальная чувствительность + -2g)
// ( 0x00 = 2g,  0x01 = 4g,  0x02 = 8g,  0x03 = 16g ) (по умолчанию 2g ADXL345_2G )
// 1g эквивалентна силе гравитации, действующей на неподвижный объект, покоящийся на поверхности Земли.
void ADXL345_setSensitivity( uint8_t value )
{
	value &= 0x03;
	uint8_t data_transmit[2];
	//читаем текущее значение регистра
	ADXL345_MemRead(DATA_FORMAT, &data_transmit[1], 1);
  data_transmit[0] = DATA_FORMAT;
	
	// применяем маску чтобы не перезаписать
  data_transmit[1] = (data_transmit[1] & 0xFC) | (value & 0x03); 
  ADXL345_MasterTransmit(data_transmit, 2);
}

//==================================================================================================================


//==================================================================================================================
// считываем диапазон измерения (максимальная чувствительность + -2g)
// ( 0x00 = 2g,  0x01 = 4g,  0x02 = 8g,  0x03 = 16g ) (по умолчанию 2g ADXL345_2G )
// 1g эквивалентна силе гравитации, действующей на неподвижный объект, покоящийся на поверхности Земли.
uint8_t ADXL345_getSensitivity(void)
{
	uint8_t data;
	//читаем текущее значение регистра
	ADXL345_MemRead(DATA_FORMAT, &data, 1);
	return (data & 0x03);
}
//==================================================================================================================	


//==================================================================================================================
// включаем оси для режима активный и неактивный с которыми будем работать
// ADXL345_ACT_X | ADXL345_ACT_Y | ADXL345_ACT_Z | ADXL345_INACT_X | ADXL345_INACT_Y | ADXL345_INACT_Z
// по умолчанию все оси включены
void ADXL345_setAxisActInactEnable( uint8_t axis )
{
	uint8_t data_transmit[2];
	//читаем текущее значение регистра
	ADXL345_MemRead(ACT_INACT_CTL, &data_transmit[1], 1);
  data_transmit[0] = ACT_INACT_CTL;
	
	// применяем маску чтобы не перезаписать
  data_transmit[1] = data_transmit[1] | 0x88 | axis; 
	
  ADXL345_MasterTransmit(data_transmit, 2);
}
//==================================================================================================================


//==================================================================================================================
// считываем какие оси включены для режима активный и неактивный с которыми будем работать
// венет маску битов ADXL345_ACT_X | ADXL345_ACT_Y | ADXL345_ACT_Z | ADXL345_INACT_X | ADXL345_INACT_Y | ADXL345_INACT_Z
// где бит 1 та ось включена
// по умолчанию все оси включены
uint8_t ADXL345_getAxisActInactEnable(void)
{
	uint8_t data;
	//читаем текущее значение регистра
	ADXL345_MemRead(ACT_INACT_CTL, &data, 1);
	return (data & 0x77);
}
//==================================================================================================================		


//==================================================================================================================
// выключаем оси для режима активный и неактивный с которыми не будем работать
// ADXL345_ACT_X | ADXL345_ACT_Y | ADXL345_ACT_Z | ADXL345_INACT_X | ADXL345_INACT_Y | ADXL345_INACT_Z
// по умолчанию все оси включены
void ADXL345_setAxisActInactDisable( uint8_t axis )
{
	uint8_t data_transmit[2];
	//читаем текущее значение регистра
	ADXL345_MemRead(ACT_INACT_CTL, &data_transmit[1], 1);
  data_transmit[0] = ACT_INACT_CTL;
	
	// применяем маску чтобы не перезаписать
  data_transmit[1] = (data_transmit[1] | 0x88) & (~axis); 
	
  ADXL345_MasterTransmit(data_transmit, 2);
}
//==================================================================================================================


//==================================================================================================================
// считываем какие оси выключены для режима активный и неактивный с которыми будем работать
// венет маску битов ADXL345_ACT_X | ADXL345_ACT_Y | ADXL345_ACT_Z | ADXL345_INACT_X | ADXL345_INACT_Y | ADXL345_INACT_Z
// где бит 1 та ось выключена
// по умолчанию все оси включены
uint8_t ADXL345_getAxisActInactDisable(void)
{
	uint8_t data;
	//читаем текущее значение регистра
	ADXL345_MemRead(ACT_INACT_CTL, &data, 1);
	return ((~data) & 0x77);
}
//==================================================================================================================		
	

//==================================================================================================================
// включаем оси для режима двойной удар одинарный удар с которыми будем работать
// ADXL345_DUB_SIN_FF_X | ADXL345_DUB_SIN_FF_Y | ADXL345_DUB_SIN_FF_Z
// по умолчанию все оси включены
void ADXL345_setAxisDubSingEnable( uint8_t axis )
{
	axis &= 0x07;
	uint8_t data_transmit[2];
	//читаем текущее значение регистра
	ADXL345_MemRead(TAP_AXES, &data_transmit[1], 1);
  data_transmit[0] = TAP_AXES;
	
	// применяем маску чтобы не перезаписать
  data_transmit[1] = data_transmit[1] | axis; 
	
  ADXL345_MasterTransmit(data_transmit, 2);
}
//==================================================================================================================


//==================================================================================================================
// считываем какие оси выключены для режима двойной удар одинарный удар с которыми будем работать
// венет маску битов ADXL345_DUB_SIN_FF_X | ADXL345_DUB_SIN_FF_Y | ADXL345_DUB_SIN_FF_Z
// где бит 1 та ось включена
// по умолчанию все оси включены
uint8_t ADXL345_getAxisDubSingEnable(void)
{
	uint8_t data;
	//читаем текущее значение регистра
	ADXL345_MemRead(TAP_AXES, &data, 1);
	return (data & 0x07);
}
//==================================================================================================================	


//==================================================================================================================
// выключаем оси для режима двойной удар одинарный удар с которыми не будем работать
// ADXL345_DUB_SIN_FF_X | ADXL345_DUB_SIN_FF_Y | ADXL345_DUB_SIN_FF_Z
// по умолчанию все оси включены
void ADXL345_setAxisDubSingDisable( uint8_t axis )
{
	axis &= 0x07;
	uint8_t data_transmit[2];
	//читаем текущее значение регистра
	ADXL345_MemRead(TAP_AXES, &data_transmit[1], 1);
  data_transmit[0] = TAP_AXES;
	
	// применяем маску чтобы не перезаписать
  data_transmit[1] = data_transmit[1] & (~axis); 
	
  ADXL345_MasterTransmit(data_transmit, 2);
}
//==================================================================================================================


//==================================================================================================================
// считываем какие оси выключены для режима двойной удар одинарный удар с которыми не будем работать
// венет маску битов ADXL345_DUB_SIN_FF_X | ADXL345_DUB_SIN_FF_Y | ADXL345_DUB_SIN_FF_Z
// где бит 1 та ось выключена
// по умолчанию все оси включены
uint8_t ADXL345_getAxisDubSingDisable(void)
{
	uint8_t data;
	//читаем текущее значение регистра
	ADXL345_MemRead(TAP_AXES, &data, 1);
	return ((~data) & 0x07);
}
//==================================================================================================================	
	
	
//==================================================================================================================
// режим Активный ( срабатывает при движении ) выбираем чувствительность от 1 до 255 (включительно )
void ADXL345_setActiveSensorSensitivity( uint8_t data )
{
	uint8_t data_transmit[2];
	
  data_transmit[0] = THRESH_ACT;
  data_transmit[1] = data; 
	
  ADXL345_MasterTransmit(data_transmit, 2);
}
//==================================================================================================================


//==================================================================================================================
// считываем чувствительность режим Активный ( срабатывает при движении ) вернет от 1 до 255 (включительно )
uint8_t ADXL345_getActiveSensorSensitivity(void)
{
	uint8_t data;
	//читаем текущее значение регистра
	ADXL345_MemRead(THRESH_ACT, &data, 1);
	return data;
}
//==================================================================================================================		
	
	
//==================================================================================================================
// режим Неактивный ( срабатывает при остановке движения ) выбираем чувствительность от 1 до 255 (включительно )
void ADXL345_setInactiveSensorSensitivity( uint8_t data )
{
	uint8_t data_transmit[2];
	
  data_transmit[0] = THRESH_INACT;
  data_transmit[1] = data; 
	
  ADXL345_MasterTransmit(data_transmit, 2);;
}
//==================================================================================================================


//==================================================================================================================
// считываем чувствительность режим Неактивный ( срабатывает при остановке движения ) вернет от 1 до 255 (включительно )
uint8_t ADXL345_getInactiveSensorSensitivity(void)
{
	uint8_t data;
	//читаем текущее значение регистра
	ADXL345_MemRead(THRESH_INACT, &data, 1);
	return data;
}
//==================================================================================================================	


//==================================================================================================================
// режим Неактивный ( срабатывает при остановке движения ) выбираем время через которое 
// после начала неактивности сенсора сработает прерывание от 1 до 255 (включительно )
// значение в миллисекундах
void ADXL345_setInactiveSensorTime( uint8_t data )
{
	uint8_t data_transmit[2];
	
  data_transmit[0] = TIME_INACT;
  data_transmit[1] = data; 
	
  ADXL345_MasterTransmit(data_transmit, 2);
}
//==================================================================================================================


//==================================================================================================================
// режим Неактивный ( срабатывает при остановке движения ) вернет время через которое 
// после начала неактивности сенсора сработает прерывание от 1 до 255 (включительно )
// значение в миллисекундах
uint8_t ADXL345_getInactiveSensorTime(void)
{
	uint8_t data;
	//читаем текущее значение регистра
	ADXL345_MemRead(TIME_INACT, &data, 1);
	return data;
}
//==================================================================================================================	
	
	
//==================================================================================================================
// режим Двойной УДАР и Одинарный УДАР ( срабатывает при двойном или одинарном ударе ) 
// выбираем чувствительность от 1 до 255 (включительно )
void ADXL345_setDoubleSingleSensorSensitivity( uint8_t data )
{
	uint8_t data_transmit[2];
	
  data_transmit[0] = THRESH_TAP;
  data_transmit[1] = data; 
	
  ADXL345_MasterTransmit(data_transmit, 2);
}
//==================================================================================================================


//==================================================================================================================
// режим Двойной УДАР и Одинарный УДАР ( срабатывает при двойном или одинарном ударе ) 
// вернет чувствительность от 1 до 255 (включительно )
uint8_t ADXL345_getDoubleSingleSensorSensitivity(void)
{
	uint8_t data;
	//читаем текущее значение регистра
	ADXL345_MemRead(THRESH_TAP, &data, 1);
	return data;
}
//==================================================================================================================		


//==================================================================================================================
// режим Двойной УДАР и Одинарный УДАР ( срабатывает при двойном или одинарном ударе ) 
// продолжительность удара от 1 до 255 (включительно )
// каждая еденица равна 625 us
void ADXL345_setDoubleSingleSensorDur( uint8_t data )
{
	uint8_t data_transmit[2];
	
  data_transmit[0] = DUR;
  data_transmit[1] = data; 
	
  ADXL345_MasterTransmit(data_transmit, 2);
}
//==================================================================================================================


//==================================================================================================================
// режим Двойной УДАР и Одинарный УДАР ( срабатывает при двойном или одинарном ударе ) 
// вернет продолжительность удара от 1 до 255 (включительно )
// каждая еденица равна 625 us
uint8_t ADXL345_getDoubleSingleSensorDur(void)
{
	uint8_t data;
	//читаем текущее значение регистра
	ADXL345_MemRead(DUR, &data, 1);
	return data;
}
//==================================================================================================================		
	
	
//==================================================================================================================
// режим Двойной УДАР и Одинарный УДАР ( срабатывает при двойном или одинарном ударе ) 
// временное окно между ударами от 1 до 255 (включительно )
// каждая еденица равна 1.25 ms
void ADXL345_setDoubleSingleSensorWindow( uint8_t data )
{
	uint8_t data_transmit[2];
	
  data_transmit[0] = WINDOW;
  data_transmit[1] = data; 
	
  ADXL345_MasterTransmit(data_transmit, 2);
}
//==================================================================================================================


//==================================================================================================================
// режим Двойной УДАР и Одинарный УДАР ( срабатывает при двойном или одинарном ударе ) 
// вернет временное окно между ударами от 1 до 255 (включительно )
// каждая еденица равна 1.25 ms
uint8_t ADXL345_getDoubleSingleSensorWindow(void)
{
	uint8_t data;
	//читаем текущее значение регистра
	ADXL345_MemRead(WINDOW, &data, 1);
	return data;
}
//==================================================================================================================		
	
	
//==================================================================================================================
// режим Двойной УДАР и Одинарный УДАР ( срабатывает при двойном или одинарном ударе ) 
// временная задержка между мериями ударов от 1 до 255 (включительно )
// Время задержки (Latency) устанавливает время после удара, в течении которого НЕ МОЖЕТ быть
// зарегистрирован второй удар (предохранение от дребезга):
// каждая еденица равна 1.25 ms
void ADXL345_setDoubleSingleSensorLatency( uint8_t data )
{
	uint8_t data_transmit[2];
	
  data_transmit[0] = LATENT;
  data_transmit[1] = data; 
	
  ADXL345_MasterTransmit(data_transmit, 2);
}
//==================================================================================================================


//==================================================================================================================
// режим Двойной УДАР и Одинарный УДАР ( срабатывает при двойном или одинарном ударе ) 
// вернет временная задержка между мериями ударов от 1 до 255 (включительно )
// Время задержки (Latency) устанавливает время после удара, в течении которого НЕ МОЖЕТ быть
// зарегистрирован второй удар (предохранение от дребезга):
// каждая еденица равна 1.25 ms
uint8_t ADXL345_getDoubleSingleSensorLatency(void)
{
	uint8_t data;
	//читаем текущее значение регистра
	ADXL345_MemRead(LATENT, &data, 1);
	return data;
}
//==================================================================================================================		
	

//==================================================================================================================
// включаем прерывание
// включать прерывание нужно только после всех настоек связаным с ним
// ADXL345_INT_DOUBLE_TAP ADXL345_INT_SINGLE_TAP и т.д.
void ADXL345_setInterruptEnable( uint8_t value )
{
	uint8_t data_transmit[2];
	//читаем текущее значение регистра
	ADXL345_MemRead(INT_ENABLE, &data_transmit[1], 1);
  data_transmit[0] = INT_ENABLE;
	
	// применяем маску чтобы не перезаписать
  data_transmit[1] = data_transmit[1] | value;
	
  ADXL345_MasterTransmit(data_transmit, 2);
}
//==================================================================================================================


//==================================================================================================================
// считываем какие прерывания включены
// включать прерывание нужно только после всех настоек связаным с ним
// вернет байт ( по маске ) нужно проверить где 1 то прерывание включено
// ADXL345_INT_DOUBLE_TAP ADXL345_INT_SINGLE_TAP и т.д.
uint8_t ADXL345_getInterruptEnable(void)
{
	uint8_t data;
	//читаем текущее значение регистра
	ADXL345_MemRead(INT_ENABLE, &data, 1);
	return data;
}
//==================================================================================================================		
	
	
//==================================================================================================================
// выключаем прерывание
// ADXL345_INT_DOUBLE_TAP ADXL345_INT_SINGLE_TAP и т.д.
void ADXL345_setInterruptDisable( uint8_t value )
{
	uint8_t data_transmit[2];
	//читаем текущее значение регистра
	ADXL345_MemRead(INT_ENABLE, &data_transmit[1], 1);
  data_transmit[0] = INT_ENABLE;
	
	// применяем маску чтобы не перезаписать
  data_transmit[1] = data_transmit[1] & (~value);
	
  ADXL345_MasterTransmit(data_transmit, 2);
}
//==================================================================================================================


//==================================================================================================================
// считываем какие прерывания выключены
// вернет байт ( по маске ) нужно проверить где 1 то прерывание выключено
// ADXL345_INT_DOUBLE_TAP ADXL345_INT_SINGLE_TAP и т.д.т.д.
uint8_t ADXL345_getInterruptDisable(void)
{
	uint8_t data;
	//читаем текущее значение регистра
	ADXL345_MemRead(INT_ENABLE, &data, 1);
	return (~data);
}
//==================================================================================================================			
	
	
//==================================================================================================================
// указываем прерывания которые будут на ножке INT1	( по умолчанию все будут на INT1 )
// настраиваем до включения самого прерывания
void ADXL345_setInterruptINT1( uint8_t value )
{
	uint8_t data_transmit[2];
	//читаем текущее значение регистра
	ADXL345_MemRead(INT_MAP, &data_transmit[1], 1);
  data_transmit[0] = INT_MAP;
	
	// применяем маску чтобы не перезаписать
  data_transmit[1] = data_transmit[1] & (~value);
	
  ADXL345_MasterTransmit(data_transmit, 2);
}
//==================================================================================================================


//==================================================================================================================
// считываем прерывания которые будут на ножке INT1	( по умолчанию все будут на INT1 )
// вернет байт ( маску ) где бит 1 то прерывание включено
// ADXL345_INT_FREE_FALL  ADXL345_INT_DOUBLE_TAP  ADXL345_INT_SINGLE_TAP и т.д.
uint8_t ADXL345_getInterruptINT1(void)
{
	uint8_t data;
	//читаем текущее значение регистра
	ADXL345_MemRead(INT_MAP, &data, 1);
	return (~data);
}
//==================================================================================================================		

	
//==================================================================================================================
// указываем прерывания которые будут на ножке INT2
// настраиваем до включения самого прерывания
void ADXL345_setInterruptINT2( uint8_t value )
{
	uint8_t data_transmit[2];
	//читаем текущее значение регистра
	ADXL345_MemRead(INT_MAP, &data_transmit[1], 1);
  data_transmit[0] = INT_MAP;
	
	// применяем маску чтобы не перезаписать
  data_transmit[1] = data_transmit[1] | value;
	
  ADXL345_MasterTransmit(data_transmit, 2);
}
//==================================================================================================================


//==================================================================================================================
// считываем прерывания которые будут на ножке INT2
// вернет байт ( маску ) где бит 1 то прерывание включено
// ADXL345_INT_FREE_FALL  ADXL345_INT_DOUBLE_TAP  ADXL345_INT_SINGLE_TAP и т.д.
uint8_t ADXL345_getInterruptINT2(void)
{
	uint8_t data;
	//читаем текущее значение регистра
	ADXL345_MemRead(INT_MAP, &data, 1);
	return data;
}
//==================================================================================================================	


//==================================================================================================================
// режим ожидания, при включенном замер не ведет при выключеном ведет замеры
// true - включаем режим ожидания false - выключаем режим ожидания
void ADXL345_setStandbyMode( bool value )
{
	uint8_t data_transmit[2];
	//читаем текущее значение регистра
	ADXL345_MemRead(POWER_CTL, &data_transmit[1], 1);
  data_transmit[0] = POWER_CTL;
	
	// применяем маску чтобы не перезаписать
  if( value ){ data_transmit[1] = data_transmit[1] & (~0x08); }
	else{ data_transmit[1] = data_transmit[1] | 0x08; }
	
  ADXL345_MasterTransmit(data_transmit, 2);
}
//==================================================================================================================


//==================================================================================================================
// считываем режим ожидания, при включенном замер не ведет при выключеном ведет замеры
// true - включен режим ожидания false - выключен режим ожидания
bool ADXL345_getStandbyMode(void)
{
	uint8_t data;
	//читаем текущее значение регистра
	ADXL345_MemRead(POWER_CTL, &data, 1);
	return !(data & 0x08);
}
//==================================================================================================================		
	
	
//==================================================================================================================
// режим Свободное падение ( срабатывает при свободном падении ) выбираем чувствительность от 1 до 255 (включительно )
// рекомендуемое (0x05 to 0x09) одна еденица равна (вес 62.5 mg)
void ADXL345_setFreeFallSensorSensitivity( uint8_t data )
{
	uint8_t data_transmit[2];
	
  data_transmit[0] = THRESH_FF;
  data_transmit[1] = data; 
	
  ADXL345_MasterTransmit(data_transmit, 2);
}
//==================================================================================================================


//==================================================================================================================
// режим Свободное падение ( срабатывает при свободном падении ) считываем чувствительность от 1 до 255 (включительно )
// рекомендуемое (0x05 to 0x09) одна еденица равна (вес 62.5 mg)
uint8_t ADXL345_getFreeFallSensorSensitivity(void)
{
	uint8_t data;
	//читаем текущее значение регистра
	ADXL345_MemRead(THRESH_FF, &data, 1);
	return data;
}
//==================================================================================================================	


//==================================================================================================================
// режим Свободное падение ( срабатывает при свободном падении ) время, которое должно пройти для засекания 
// свободного падения . значение от 1 до 255 одна еденица 5 мс, рекомендуют (0x14 to 0x46)
void ADXL345_setFreeFallSensorTime( uint8_t data )
{
	uint8_t data_transmit[2];
	
  data_transmit[0] = TIME_FF;
  data_transmit[1] = data; 
	
  ADXL345_MasterTransmit(data_transmit, 2);
}
//==================================================================================================================


//==================================================================================================================
// режим Свободное падение ( срабатывает при свободном падении ) считываем время, которое должно пройти для засекания 
// свободного падения . значение от 1 до 255 одна еденица 5 мс, рекомендуют (0x14 to 0x46)
uint8_t ADXL345_getFreeFallSensorTime(void)
{
	uint8_t data;
	//читаем текущее значение регистра
	ADXL345_MemRead(TIME_FF, &data, 1);
	return data;
}
//==================================================================================================================	


//==================================================================================================================
// после возникновения прерывания читаем его регист
// функция возвращает тип прерывание вызваное датчиком
// ( важно!!! внутри прерывания нельзя читать байт который указывает на тип прерывания датчика,
// иначе новое прерывание уже не отработает, поєтому взводим флаг и в цикле уже читаем тип прерывания датчика)
// читаем байт в котором побитово можно увидеть что именно ыфзвало прерывание, нужно читать после каждого прерывания ( биты комбенируем через маски )
// ADXL345_INT_SINGLE_TAP  	0x40 - однократный удар
// ADXL345_INT_DOUBLE_TAP 	0x20 - двойной удар
// ADXL345_INT_ACTIVITY	 		0x10 - любая активность ( удары )
// ADXL345_INT_INACTIVITY 	0x08 - бездействие
// ADXL345_INT_FREE_FALL  	0x04 - свободное падение
// ADXL345_INT_DATA_READY 	0x80 - данные готовы
uint8_t ADXL345_ReadInterruptReg(void)
{
	uint8_t data;
	ADXL345_MemRead(INT_SOURCE, &data, 1);
	return data;
}
//==================================================================================================================


//==================================================================================================================
// читаем  RAW  данные по оси X
int16_t ADXL345_ReadRawAxisX(void)
{
	uint8_t raw[2];
	ADXL345_MemRead(DATAX0, raw, 2);
	return ((int16_t)(raw[1] << 8) | raw[0]);
}
//==================================================================================================================		


//==================================================================================================================
// читаем  RAW  данные по оси Y
int16_t ADXL345_ReadRawAxisY(void)
{
	uint8_t raw[2];
	ADXL345_MemRead(DATAY0, raw, 2);
	return ((int16_t)(raw[1] << 8) | raw[0]);
}
//==================================================================================================================


//==================================================================================================================
// читаем  RAW данные по оси Z
int16_t ADXL345_ReadRawAxisZ(void)
{
	uint8_t raw[2];
	ADXL345_MemRead(DATAZ0, raw, 2);
	return ((int16_t)(raw[1] << 8) | raw[0]);
}
//==================================================================================================================


//==================================================================================================================
// читаем данные по всем трем осям одновременно X Y Z
void ADXL345_ReadAxisXYZ(int16_t* x, int16_t* y, int16_t* z)
{
	uint8_t raw[6];
	ADXL345_MemRead(DATAX0, raw, 6);
	*x = ((int16_t)(raw[1] << 8) | raw[0]);
	*y = ((int16_t)(raw[3] << 8) | raw[2]);
	*z = ((int16_t)(raw[5] << 8) | raw[4]);
}
//==================================================================================================================


//==================================================================================================================
// в режиме SPI выбор 3 или 4 проводная линия
// If Set (1) Puts Device in 3-wire Mode
// If Set (0) Puts Device in 4-wire SPI Mode
// Default = 1
void ADXL345_setBitSPI( bool level )
{
	uint8_t data_transmit[2];
	//читаем текущее значение регистра
	ADXL345_MemRead(DATA_FORMAT, &data_transmit[1], 1);
  data_transmit[0] = DATA_FORMAT;
	
	// применяем маску чтобы не перезаписать
  if( !level ){ data_transmit[1] = (data_transmit[1] & 0xBF); }	
	else{ data_transmit[1] = (data_transmit[1] & 0xBF) | 0x40; }	
	
  ADXL345_MasterTransmit(data_transmit, 2);
}			
//==================================================================================================================


//==================================================================================================================
// смещение OFSX: User Offset Adjustments in Twos Complement Format
// Scale Factor of 15.6mg/LSB
// делаем смещение по оси от -150mg до +150mg ( 1 еденица равна 15.6mg )
void ADXL345_setAxisOffsetX(int8_t data)
{
	uint8_t data_transmit[2];
	
  data_transmit[0] = OFSX;
  data_transmit[1] = data; 
	
  ADXL345_MasterTransmit(data_transmit, 2);
}
//==================================================================================================================


//==================================================================================================================
// считываем смещение OFSX: User Offset Adjustments in Twos Complement Format
// Scale Factor of 15.6mg/LSB
// делаем смещение по оси от -150mg до +150mg ( 1 еденица равна 15.6mg )
int8_t ADXL345_getAxisOffsetX(void)
{
	uint8_t data;
	//читаем текущее значение регистра
	ADXL345_MemRead(OFSX, &data, 1);
	return data;
}
//==================================================================================================================


//==================================================================================================================
// смещение OFSY: User Offset Adjustments in Twos Complement Format
// Scale Factor of 15.6mg/LSB
// делаем смещение по оси от -150mg до +150mg ( 1 еденица равна 15.6mg )
void ADXL345_setAxisOffsetY(int8_t data)
{
	uint8_t data_transmit[2];
	
  data_transmit[0] = OFSY;
  data_transmit[1] = data; 
	
  ADXL345_MasterTransmit(data_transmit, 2);
}
//==================================================================================================================


//==================================================================================================================
// считываем смещение OFSY: User Offset Adjustments in Twos Complement Format
// Scale Factor of 15.6mg/LSB
// делаем смещение по оси от -150mg до +150mg ( 1 еденица равна 15.6mg )
int8_t ADXL345_getAxisOffsetY(void)
{
	uint8_t data;
	//читаем текущее значение регистра
	ADXL345_MemRead(OFSY, &data, 1);
	return data;
}
//==================================================================================================================


//==================================================================================================================
// смещение OFSZ: User Offset Adjustments in Twos Complement Format
// Scale Factor of 15.6mg/LSB
// делаем смещение по оси Z от -250mg до +250mg ( 1 еденица равна 15.6mg )
void ADXL345_setAxisOffsetZ(int8_t data)
{
	uint8_t data_transmit[2];
	
  data_transmit[0] = OFSZ;
  data_transmit[1] = data; 
	
  ADXL345_MasterTransmit(data_transmit, 2);
}
//==================================================================================================================


//==================================================================================================================
// считываем смещение OFSZ: User Offset Adjustments in Twos Complement Format
// Scale Factor of 15.6mg/LSB
// делаем смещение по оси Z от -250mg до +250mg ( 1 еденица равна 15.6mg )
int8_t ADXL345_getAxisOffsetZ(void)
{
	uint8_t data;
	//читаем текущее значение регистра
	ADXL345_MemRead(OFSZ, &data, 1);
	return data;
}
//==================================================================================================================

//==================================================================================================================
// Калибровка осей акселерометра ( нужна для получения градусов наклона,
// если это не нужно калибровать нет смысла, для более точного получения градусов наклона ADXL345_setSensitivity() устанавливать на ADXL345_16G )
// запускаем калибровку после установки ADXL345_setSensitivity()
// в момент калибровки нужно вращать ( крутить ) датчик во всех направлениях ( но окуратно без ударов и резких движений так как они некоректно влияют на калибровку )
// в этот момент калибровка будет записывать в функцию максимум и минимум значения как только значения запишуться и новых небудет 
// то по истечении времени #define TIME_CALIB_END калибровка закончиться и в датчик будут записаны смещения ADXL345_setAxisOffset_ для всех осей
// эти данные храняться в датчике пока есть питание ( после перезагрузки там будут 0 )
// если мы хотим при следующем включении не калибровать то можно после калибровки 
// с помощью функций ADXL345_getAxisOffset_ считать все смещения и записать в EEPROM. 
// а при запуске устройства оттуда считывать и уже напрямую записывать в датчик без калибровки с помощью функции ADXL345_setAxisOffset_
void ADXL345_AccelerometerCalibration(void)
{
		// время которое пройдет после того какне будут изменены значения
		#define TIME_CALIB_END			10000		// millisec
		
		int AccelMinX = 0;
		int AccelMaxX = 0;
		int AccelMinY = 0;
		int AccelMaxY = 0;
		int AccelMinZ = 0;
		int AccelMaxZ = 0; 

		float offsetAxisX = 0.0f;
		float offsetAxisY = 0.0f;
		float offsetAxisZ = 0.0f;
		
		int16_t X_axis_raw_value = 0;
		int16_t Y_axis_raw_value = 0;
		int16_t Z_axis_raw_value = 0;
		
		// обнуляем смещение
		ADXL345_setAxisOffsetX(	0 );
		ADXL345_setAxisOffsetY( 0 );
		ADXL345_setAxisOffsetZ( 0 );
				
		uint32_t time_calib_end = HAL_GetTick();
		
		// постонно считываем данные ( ищем максимум и минимум )
		// как только новых данных не будет пройдет указаное время и калибровка будет завершена
		while( HAL_GetTick() - time_calib_end < TIME_CALIB_END ){
			
			// получаем данные по осям ( также их можно получать по прерыванию )
			X_axis_raw_value = ADXL345_ReadRawAxisX();			
			Y_axis_raw_value = ADXL345_ReadRawAxisY();
			Z_axis_raw_value = ADXL345_ReadRawAxisZ();
			
			
			  if(X_axis_raw_value < AccelMinX) {AccelMinX = X_axis_raw_value; time_calib_end = HAL_GetTick(); };
				if(X_axis_raw_value > AccelMaxX) {AccelMaxX = X_axis_raw_value; time_calib_end = HAL_GetTick(); };

				if(Y_axis_raw_value < AccelMinY) {AccelMinY = Y_axis_raw_value; time_calib_end = HAL_GetTick(); };
				if(Y_axis_raw_value > AccelMaxY) {AccelMaxY = Y_axis_raw_value; time_calib_end = HAL_GetTick(); };

				if(Z_axis_raw_value < AccelMinZ) {AccelMinZ = Z_axis_raw_value; time_calib_end = HAL_GetTick(); };
				if(Z_axis_raw_value > AccelMaxZ) {AccelMaxZ = Z_axis_raw_value; time_calib_end = HAL_GetTick(); };
	
				offsetAxisX = 0.5f * (AccelMaxX + AccelMinX);
				offsetAxisY = 0.5f * (AccelMaxY + AccelMinY);
				offsetAxisZ = 0.5f * (AccelMaxZ + AccelMinZ);
				
				
			}
		
			// записываем в датчик смещение
			ADXL345_setAxisOffsetX(	(offsetAxisX / ( 1024 / SensitivityRangesResolution[ ADXL345_getSensitivity() ]) ) );
			ADXL345_setAxisOffsetY( (offsetAxisY / ( 1024 / SensitivityRangesResolution[ ADXL345_getSensitivity() ]) ) );
			ADXL345_setAxisOffsetZ( (offsetAxisZ / ( 1024 / SensitivityRangesResolution[ ADXL345_getSensitivity() ]) ) );	
}
//==================================================================================================================



//----------------------------------------------------------------------------------

/************************ (C) COPYRIGHT GKP *****END OF FILE****/
